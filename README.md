# Lab6
Программа представляет из себя лабораторную работу под номером 6 по дисциплине «Язык программирования C#». Лабораторная состоит из двух задач на тему интерфейсов и шаблонов ООП.

## Требования
* Windows 10 (или выше)
* Visual Studio

## Установка и запуск программы
1. Клонируйте репозиторий в Visual Studio
2. Соберите решение (Ctrl+Shift+B)
3. Запустите (Ctrl+F5)

## Руководство по использованию
1. Введите номер задачи.
2. Следуйте дальнейшим инструкциям внутри задачи.
3. После выполнения задачи введите номер новой или 0 для выхода из программы.

## Структура проекта
Lab4
* Program.cs
* InputValidation.cs
* Tasks.cs
* Cat.cs
* QuasiCat.cs
* IMeowable.cs
* Fraction.cs

Program.cs – основной файл, содержащий класс Program и метод Main. В нём в консоль выводится список задач и запрашивается номер задачи, после чего вызывается метод соответствующей задачи из класса Tasks.

InputValidation.cs – файл с функцией корректного ввода числа типа int

Tasks.cs – файл, в котором содержатся методы задач в классе Tasks.

Cat.cs - файл, в котором содержится класс Cat.

QuasiCat.cs - файл, в котором содержится класс QuasiCat.

IMeowable.cs - файл, в котором содержится интерфейс IMeowable.

Fraction.cs - файл, в котором содержится класс Fraction.

## Задачи

1. Кот

1.1. Кот мяукает.

Формулировка:

Создайте сущность Кот, которая описывается следующим образом:
• Имеет Имя (строка)
• Для создания необходимо указать имя кота.
• Может быть приведен к текстовой форме вида: “кот: Имя”
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”,
вызвать мяуканье можно без параметров.
• Может помяукать N раз, что приводит к выводу на экран следующего текста: “Имя: мяу-мяу-…-мяу!”, где количество “мяу”равно N.
Создайте кота по имени “Барсик”, и затем пусть он помяукает сначала один раз, а затем три раза.

Алгоритм: 

Создаётся экземпляр класса Cat с параметром "Барсик". Вызываются методы Meow, сначала без параметров, потом с параметром 3.

Результат:

Появился кот по кличке Барсик.
Барсик: мяу!
Барсик: мяу-мяу-мяу!

1.2. Интерфейс Мяуканье.

Формулировка:

Разработайте метод, который принимает набор объектов способных мяукать и вызывает мяуканье у
каждого объекта. Мяукающие объекты должны иметь метод со следующей сигнатурой:
public void Meow();
Дополните решение предыдущей задачи так, чтобы иметь возможность передать Кота в написанный
вами метод и протестируйте работоспособность решения передав в него нескольких котов, а также
создайте любой другой произвольный класс и передайте в написанный метод его объекты.

Алгоритм: 

Классу Cat присваивается созданный интерфейс IMeowable.
Создаются два экземпляра класса Cat и один класса QuasiCat.
Все они передаются как параметры в метод UniversalMeow.

Результат:
Барсик: мяу!
Мурзик: мяу!
wxwd7891: мяу?

1.3. Количество мяуканий. 

Формулировка:

Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из предыдущего
задания. Необходимо таким образом передать кота в указанный метод, что бы после окончания его
работы узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед
вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы
выводим количество мяуканий на экран. Кота изменять нельзя.

Алгоритм:

В классе Cat создаются поле _counter и метод HowMuchMeows. 
При вызове метода Meow в счётчик добавляется соответствующее количество мяуканий. 

Результат:

Барсик: мяу!
Барсик: мяу-мяу-мяу!
У кота по кличке Барсик были мяуканья в количестве: 4.
Барсик: мяу!
У кота по кличке Барсик были мяуканья в количестве: 5.

2. Дроби

2.1. Дроби.

Формулировка:

Создайте сущность Дробь со следующими особенностями:
• Имеет числитель: целое число
• Имеет знаменатель: целое число
• Дробь может быть создана с указанием числителя и знаменателя
• Может вернуть строковое представление вида “числитель/знаменатель”
• Может выполнять операции сложения, вычитания, умножения и деления с другой
Дробью или целым числом. Результатом операции должна быть новая Дробь (таким
образом, обе исходные дроби не изменяются) (Обязательно использовать перегрузки!)
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не
может быть отрицательным.
Затем необходимо выполнить следующие задачи:
1. Создать несколько экземпляров дробей.
2. Написать по одному примеру использования каждого метода.
3. Вывести на экран примеры и результаты их выполнения в формате «1/3 * 2/3 = 2/9»
4. Посчитать (f1 + f2) / f3 - 5

Алгоритм:

Последовательно создаются три экземпляра класса Fraction со значениями, введёнными пользователем.
С дробями выполняются операции, указанные в формулировке.

Результат:

1/2 + 1/3 = 5/6
5/6 / 1/7 = 35/6
35/6 - 5 = 5/6

2.2. Сравнение дробей.

Формулировка:

Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.

Алгоритм:

Для класса Fraction переопределён метод Equals и перегружены операторы сравнения.

Результат:

Равны ли дроби 1/2 и 1/2? True
Равны ли дроби 1/3 и 1/2? False

2.3. Клонирование дроби. Интерфейс ICloneable.

Формулировка:

Переопределите метод клонирования, таким образом, чтобы при его вызове возвращался новый
объект Дроби, значения полей которого будут копиями оригинальной Дроби

Алгоритм:

Классу Fraction присваивается интерфейс ICloneable и переопределяется метод Clone.

Результат:

Дробь f7(1/2) это клон дроби f6(1/2)

2.4 Получение вещественного значения.

Формулировка:

В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка
числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного
значения.

Алгоритм:

Классу Fraction присваиваются интерфейсы IRealValue и INumeratorDenominator, добавлено поле _cash.

Результат:

Вещественное значение дроби f7(1/2) до вычисления кэша:
Вещественное значение f7(1/2) после вычисления кэша: 0,5

## Автор
Костицын Семён, ИТ-11-12-2024
